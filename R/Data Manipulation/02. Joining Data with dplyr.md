Joining Data with dplyr
=======================

# 1. Joining Tables


Got It!
1. The inner_join verb
In other DataCamp courses, you may have learned to use the powerful dplyr package to explore and transform a dataset. But the information you'll need for an analysis isn't always confined to one table.

2. LEGO dataset
In this course, you'll master the important skill of joining multiple tables together, so that they can be analyzed in combination. You'll work with a fun dataset about the construction toys known as LEGOs. The data comes from the Rebrickable website, and has tons of fun information about the sets, parts, themes, and colors that make up LEGO history. The dataset is fascinating, but it's spread across many tables. You'll run into this kind of data a lot if you work in data science.

3. The sets table
In this chapter you'll be focusing on one dplyr verb, inner join, and you'll start by working with the sets table in the LEGO data. This table contains one row for each of the 4,977 LEGO sets, starting with sets like "Medium Gift Set" back in 1949. Notice that there is a column that's not useful on its own: theme-underscore-id. That's because the useful information- the theme name- is in a separate table, called themes.

4. Linking two tables
The theme id variable in the sets table links to the id variable in the themes table. For any individual set, we could find a theme that matches it.

5. Inner join
To see the theme that each set is associated with, we'll need to join the two tables. To do this, you use inner join. This joins the first table "sets" to the second table "themes". Notice that the argument by equals theme-underscore-id equals id. That tells inner join how to match the tables: linking theme id in the first table to id in the second table. Notice that in the output, you've combined the two tables, combining each set with its theme. But because both tables had a variable called name, you end up with name-dot-x, with the set's name, and name-dot-y, with the theme's name, because you can not have two variables with the same name. Inner join lets you customize this to be more readable!

6. Customizing your join
Add another argument, suffix equals c underscore set, comma, underscore theme. This appends underscore set or underscore theme to the shared columns, which gets the much more readable name underscore set and name underscore theme.

7. Most common themes
Now we can answer interesting questions about the data. For instance, we could find out what the most common themes are in LEGO history by piping again to count name underscore theme, with sort equals TRUE. This pattern of taking two tables, finding a link between them, and joining them together is very common, and will enable you to make a lot of interesting discoveries throughout this course.

8. Other LEGO tables
For starters: in the exercises you'll learn about two new tables from the LEGO dataset, parts and part-underscore-categories, and then practice joining them together.

9. Part
A part is a shape, like a gear, a 2 by 4 brick, or a figurine, and they'll come up a lot in this course.

## 1.2 Joining with a one-to-many relationship



1. Joining with a one-to-many relationship
In the first lesson, you joined the sets table to the themes table.

2. Joining sets and themes
Each set has exactly one theme, so the joined table has exactly as many observations as the sets table: 4,977.

3. The inventories table
But not all joins work that way. Let's introduce a new table, inventories. An inventory represents a product that's made up of some combination of parts. Notice that inventories has the variable set num, which suggests it links to the "set num" variable from our sets table.

4. Joining sets and inventories
Let's try using that variable to join sets to inventories. Something convenient is that when the variables you're joining by have the same name, you can just write by equals quote set-underscore-num unquote. This is in contrast to the way we earlier did c theme-underscore-id equals id. Notice that while we started with 4,977 sets, our joined result now has 5,056. This is because each set can have multiple versions, each of which gets its own inventory item. For instance, we can see that Medium Gift Set from 1949 has three versions, and Single 2 by 4 brick has five versions.

5. Filtering the joined table
One way we can confirm our understanding is to filter this joined table for only the first version. Notice this results in a table with 4,976 observations, compared to our 4,977. This means there's one set that doesn't have a version 1, which is probably a data quality issue. An inner join keeps an observation only if it has an exact match between the first and the second tables. We'll return to how we could find a missing observation in later chapters, and you'll also see that paying close attention to the number of rows before and after a join is an important part of understanding your data.

6. Parts and pieces
In the exercises, you'll be returning to the parts table. But you'll also see each LEGO piece has another attribute besides its part: its color.

7. The inventory parts
The inventory parts table is what combines a part and a color. That combination describes a single LEGO piece, which in turn is a part of an inventory. You'll see how all of these connect in the rest of this chapter.



