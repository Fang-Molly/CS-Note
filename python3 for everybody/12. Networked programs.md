# Chapter 12  Networked programs

## 12.1 Hypertext Transfer Protocol - HTTP

* **Transport control protocol (TCP)**

   * Built on top of IP (Internet Protocol)
   * Assumes IP might lose some data-stores and retransmits data if it seems to be lost
   * Handles "flow control" using a transmit window
   * Provides a nice reliable pipe 

* **TCP Connections / socket** : built-in support in Python

   * like a file
   
   * A single socket provides a two-way connection between two programs. You can read from and write to the same socket.

* **TCP Port Numbers**

   * A port is an application-specific or process-specific software communications endpoint
   * It allows multiple networked applications to coexist on the same server
   * There is a list of well-known TCP port numbers
 
* **Common TCP Ports**

   * Telnet (23) - Login
   * SSH (22) - Secure Login
   * HTTP (80)
   * HTTPS (443) -Secure
   * SMTP (25) - Mail
   * IMAP (143/220/993) - Mail
   * POP (109/110) - Mail
   * DNS (53) - Domain Name
   * FTP (21) - File Transfer

* **Sockets in Python**

   * Python has built-in support for TCP Sockets

```python
>>> import socket
>>> mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
>>> mysock.connect(('data.pr4e.org', 80))   # Host(data.pr4e.org); Port(80)
```

* **HTTP - Hypertext Transfer Protocol**

   * The dominant Application Layer Protocol on the Internet
   * Invented for the Web - to Retrieve HTML, Images, Documents, etc.
   * Extended to be data in addition to documents - RSS, Web Services, etc. 
      * Basic Concept - Make a Connection - Request a document - Retrieve the Document - Close the Connection
      
> http://www.dr-chuck.com/pagel.htm   
> * protocol: http://     
> * host: www.dr-chuck.com     
> * document: pagel.htm     

## 12.2 The world's simplest web browser

```python
import socket

mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
mysock.connect(('data.pr4e.org', 80))
cmd = 'GET http://data.pr4e.org/romeo.txt HTTP/1.0\r\n\r\n'.encode()
mysock.send(cmd)

while True:
    data = mysock.recv(512)
    if len(data) < 1:
        break
    print(data.decode(), end='')
mysock.close()

$ python3 http.py
HTTP/1.1 200 OK
Date: Wed, 17 Mar 2021 20:41:54 GMT
Server: Apache/2.4.18 (Ubuntu)
Last-Modified: Sat, 13 May 2017 11:22:22 GMT
ETag: "a7-54f6609245537"
Accept-Ranges: bytes
Content-Length: 167
Cache-Control: max-age=0, no-cache, no-store, must-revalidate
Pragma: no-cache
Expires: Wed, 11 Jan 1984 05:00:00 GMT
Connection: close
Content-Type: text/plain

But soft what light through yonder window breaks
It is the east and Juliet is the sun
Arise fair sun and kill the envious moon
Who is already sick and pale with grief
```

* **ASCII - American Standard Code for Information Interchange**

   * Each character is represented by a number between 0 and 256 stored in 8 bits of memory
   * We refer to "8 bits of memory as a "byte" of memory - (i.e. my disk drive contains 3 Terabytes of memory)
   * The `ord()` function tells us the numeric value of a simple ASCII character

```python
>>> ord('H')
72
>>> ord('e')
101
>>> print(ord('\n'))
10
```

* **Multi-Byte Characters** : To represent the wide range of characters computers must handle we represent characters with more than one byte

   * UTF-16 - Fixed length - Two bytes
   * UTF-32 - Fixed length - Four bytes
   * UTF-8 - 1-4 bytes
      * Upwards compatible with ASCII
      * Automatic detection between ASCII and UTF-8
      * UTF-8 is recommended practice for encoding data to be exchaned between systems

* **Python3 and Unicode**

   * In Python3, all strings internally are UNICODE
   * Working with string variables in python programs and reading data from files usually "just works"
   * When we talk to a network resource using sockets or talk to a database we have to encode and decode data (usually to UTF-8)
   
```python
>>> x = b'abc'
>>> type(x)
<class 'bytes'>
>>> x = '이광춘'
>>> type(x)
<class 'str'>
>>> x = u'이광춘'
>>> type(x)
<class 'str'>
```

   *  encode() and decode() methods convert strings into bytes objects and back again
      * a bytes object.encode() and b'' are equivalent
```
>>> b'Hello world'
b'Hello world'
>>> 'Hello world'.encode()
b'Hello world'
```
> * `encode()`: String Unicode --> Bytes UTF-8
> * `decode()`: Bytes UTF-8 --> String Unicode
> * `send()`: Bytes UTF-8 --> Socket
> * `recv()`: Socket --> Bytes UTF-8

* **Using urllib in Python**

```python
import urllib.request, urllib.parse, urllib.error

fhand = urllib.request.urlopen('http://data.pr4e.org/romeo.txt')
for line in fhand:
    print(line.decode().strip())

$ python3 urllib.py
But soft what light through yonder window breaks
It is the east and Juliet is the sun
Arise fair sun and kill the envious moon
Who is already sick and pale with grief
```


## 12.3 Retrieving an image over HTTP









## 12.4 Retrieving web pages with urllib

## 12.5 Reading binary files using urllib

## 12.6 Parsing HTML and scraping the web

## 12.7 Parsing HTML using regular expressions

## 12.8 Parsing HTML using BeautifulSoup

## 12.9 Bonus section for Unix / Linux users

## 12.10 Glossary

BeautifulSoup A Python library for parsing HTML documents and extracting data from HTML documents that compensates for most of the imperfections in the HTML that browsers generally ignore. You can download the Beauti- fulSoup code from www.crummy.com.

port A number that generally indicates which application you are contacting when you make a socket connection to a server. As an example, web traffic usually uses port 80 while email traffic uses port 25.

scrape When a program pretends to be a web browser and retrieves a web page, then looks at the web page content. Often programs are following the links in one page to find the next page so they can traverse a network of pages or a social network.

socket A network connection between two applications where the applications can send and receive data in either direction.

spider The act of a web search engine retrieving a page and then all the pages linked from a page and so on until they have nearly all of the pages on the Internet which they use to build their search index.

## 12.11 Exercises

Exercise 1: Change the socket program socket1.py to prompt the user for the URL so it can read any web page. You can use split('/') to break the URL into its component parts so you can extract the host name for the socket connect call. Add error checking using try and except to handle the condition where the user enters an improperly formatted or non-existent URL.


Exercise 2: Change your socket program so that it counts the number of characters it has received and stops displaying any text after it has shown 3000 characters. The program should retrieve the entire docu- ment and count the total number of 
characters and display the count of the number of characters at the end of the document.


Exercise 3: Use urllib to replicate the previous exercise of (1) retrieving the document from a URL, (2) displaying up to 3000 characters, and (3) counting the overall number of characters in the document. Don’t worry about the headers for this exercise, simply show the first 3000 characters of the document contents.


Exercise 4: Change the urllinks.py program to extract and count para- graph (p) tags from the retrieved HTML document and display the count of the paragraphs as the output of your program. Do not display the paragraph text, only count them. Test your program on several small web pages as well as some larger web pages.


Exercise 5: (Advanced) Change the socket program so that it only shows data after the headers and a blank line have been received. Remember that recv receives characters (newlines and all), not lines.
