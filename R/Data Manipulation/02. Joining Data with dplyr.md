Joining Data with dplyr
=======================

# 1. Joining Tables

## 1.1 The inner_join verb

* **Inner join**

```R
# link the column in the first table to the column in the second table
sets %>%
  inner_join(themes, by = c("theme_id" = "id"))
```

* **Customizing your join**

```R
# append suffix name to the shared columns, much more readable name
sets %>%
	inner_join(themes, by = c("theme_id" = "id"), suffix = c("_set", "_theme"))
```

* **Most common themes**

```R
# find out the most common themes 
sets %>%
	inner_join(themes, by = c("theme_id" = "id"), suffix = c("_set", "_theme")) %>%
	count(name_theme, sort = TRUE)
```


## 1.2 Joining with a one-to-many relationship

* Filtering the joined table 

```R
sets %>%
	# join by the same name
	inner_join(inventories, by = "set_num")
	filter(version == 1)
```
  
## 1.3 Joining three or more tables

* **Adding another join**

```R
sets %>%
	inner_join(inventories, by = "set_num") %>%
	inner_join(themes, by = c("theme_id" = "id"), suffix = c("_set", "_theme"))
```

# 2. Left and Right Joins

## 2.1 The left_join verb

```R
invertory_parts_joined <- inventories %>%
	inner_join(inventory_parts, by = c("id" = "inventory_id")) %>%
	select(-id, -version) %>%
	arrange(desc(quantity))
```

* **Fliter**

```R
batmobile <- inventory_parts_joined %>%
	filter(set_num == "7784-1") %>%
	select(-set_num)
	
batwing <- inventory_parts_joined %>%
	filter(set_num == "70916-1") %>%
	select(-set_num)
```

* **Joining with multiple columns**

```R
batmobile %>%
	inner_join(batwing, by = c("part_num", "color_id"), suffix = c("_batmobile", "_batwing"))
```

* **The left join**

		* keep all the observations from the first (or "left") table

```
batmobile %>%
	left_join(batwing, by = c("part_num", "color_id"), suffix = c("_batmobile", "_batwing"))
```

## 2.2 The right-join verb

* **The right join**

		* Keep all the observations in the second (or "right") table

```R
batmobile %>%
	right_join(batwing, by = c("part_num", "color_id"), suffix = c("_batmoblie", "_batwing"))
```

* **Count and sort**

```R
sets %>%
	# count how many times the theme_id happens
	count(theme_id, sort = TRUE) %>%
	# add more information
	inner_join(themes, by = c("theme_id" = "id))
```

* **Replace NAs**

```R
sets %>%
	count(theme_id, sort = TRUE) %>%
	right_join(themes, by = c("theme_id" = "id")) %>%
	replace_na(list(n = 0))
```

* **Compariation**

		* inner_join : keep only observations that match perfectly between tables
		* left_join : keep all observations in the first table, including matching observations in the second table
		* right_join : keep all observations in the second table, including matching observations in the first table

## 2.3 Joining tables to themselves

```R
# join tables to themselves
themes %>%
	inner_join(themes, by = c("parent_id" = "id"))
	
# add a suffix
themes %>%
	inner_join(themes, by = c("parent_id" = "id"), suffix = c("_child", "_parent")
	
# filter
themes %>%
	inner_join(themes, by = c("parent_id" = "id"), suffix = c("_child", "_parent") %>%
	filter(name_child == "The Lord of the Rings")
```
 
# 3. Full, Semi, and Anti Joins

## 3.1 The full_join verb

* `full_join` : keep all observations in both tables, whether or not they matched to each other?

```R
batmobile %>%
	full_join(batwing, by = c("part_num", "color_id"), suffix = c("_batmobile", "_batwing")) %>%
	replace_na(list(quantity_batmobile = 0, quantity_batwing = 0))
```

## 3.2 The semi- and anti-join verbs


1. The semi- and anti-join verbs
You've learned about four joining verbs so far: inner join, left join, right join, and full join.

2. Mutating verbs
All of these are what we call mutating verbs: they combine the variables from your two tables.

3. Review: left join
For example, when you left joined batmobile and batwing, you ended up with a new column you did not have in batmobile: specifically, quantity underscore batwing.

4. Filtering joins
But let's talk about a different class of verbs: filtering joins. A filtering join keeps or removes observations from the first table, but it doesn't add new variables. The two filtering verbs you'll be learning are semi join and anti join.

5. Filtering joins
A semi join asks the question: what observations in X are also in Y?

6. Filtering joins
And an anti join asks the question: what observations in X are not in Y?

7. The semi join
Let's start with semi join. What parts used in the Batmobile set are also used in the Batwing set? This semi join takes us from the 173 pieces that are in the Batmobile set and reduces it to the 45 pieces that are also in the Batwing set. But notice that we still have the same three variables- part num, color id, and quantity: that the Batmobile set started with. We kept Batmobile's quantity variable, and didn't even have to specify a suffix. This is useful for when we want to filter down a table without modifying it further.

8. The anti join
The opposite of a semi join is an anti join. Anti joins ask: what observations in the first table are not in the second table? In this case, what pieces are in the batmobile but not in the batwing. Notice again, we did not specify a suffix. The result tells us that there are 128 pieces in the Batmobile that are not in the Batwing.

9. Filtering with semi join
These verbs aren't useful just for comparing Batman's rides. You could use them to filter down the other tables we've worked with. For example, you might want to know what themes ever appear in a set. A semi join tells you that 569 themes make at least one appearance.

10. Filtering with anti join
Conversely, you could use anti join to find the themes never appear in a set in our database. This filters down to the 96 that don't match to anything.

11. The joining verbs
In the exercises, you'll find other useful applications of the semi and anti joins. Before long, you'll have six joining verbs in your dplyr arsenal.



## 3.3 Visualizing set differences

1. Visualizing set differences
So far in this chapter, you've been working with the batmobile and batwing tables, which contain the pieces for each of the two LEGO sets. Let's say that instead of working with pieces, you wanted to examine and compare the colors used in each set. This will take a little effort, but it will make a great and intuitive visualization of the differences in the color palettes between the Batmobile and the Batwing.

2. Aggregating sets into colors
Before doing any joining, you'll want to aggregate each set into colors. You've learned how to do this in dplyr with group by and summarize. You can create a total column equal to the sum of the quantity column. We could do the same aggregation for both the batmobile and batwing sets. You now have two tables, one for each set, where each table has one observation per color. The tables have only the color IDs right now, but we'll be joining in the color names later.

3. Comparing color schemes of sets
Earlier in this chapter you learned about full join, and in Chapter 2 you learned about replace na from tidyr. Using these together, you can combine both tables into one table, and replace nas in the total batmobile and total batwing columns. This is the format you'll want for comparing the color schemes of the two sets.

4. Adding the color names
We still have only the color IDs, so we'll want to bring in the color names using an inner join, joining the color id column to the id column. There's still a little more dplyr processing to do before we can have a meaningful comparison of the two sets. First, the two quantities are hard to compare because the two sets have different total numbers of pieces. You'll want to normalize each of the colors, by turning them into fractions of the total.

5. Adding fractions
You've probably learned before that you can add or change columns with the mutate verb. You can turn the columns into fractions by dividing each of the columns by its sum: total batmobile divided by sum total batmobile, and you can do the same to total batwing. Now, instead of looking at the raw number of pieces, you can see that Batmobile is 51-point-6 percent black pieces, while Batwing is only 39-point-7 percent black pieces.

6. The difference between fractions
There's one more step in our comparison within the joined data. What you care about most is the difference between fractions: the Batmobile has more black pieces, and the Batwing has more dark bluish gray. You can add this in as one more step in the mutate: difference equals total batmobile minus total batwing. We'll save this object as colors underscore joined. This has taken a lot of work! But, now that you've processed the joined data, we can easily see which colors are more represented in one set or the other.

7. Visualizing the data
After processing the data, we're ready to visualize it. This isn't a visualization course though, so we won't go over how the visualization works, and we'll provide the visualization code for you in the exercises. But, if you're interested, the code uses a scale fill manual to set up the colors to match the RGB values, and a function from forcats called fct reorder to reorder the columns meaningfully.

8. Visualizing the data
Here's the resulting bar plot. Notice that, thanks to your joining and post-processing, you've got an interpretable visualization of the comparison between the two sets. The bars on the right, like Black and Light Bluish Gray, have positive differences, meaning they're more common in the batmobile set. The colors on the left, like Red and Dark Bluish Gray, are more common in the Batwing. This shows how joining two tables together can fit with other data manipulation and visualization tasks as a part of a larger data science workflow.

9. Comparing Batman and Star Wars themes
In the exercises, you'll use a similar approach to compare two entire LEGO themes to discover the differences in LEGO color schemes between Batman and Star Wars.


